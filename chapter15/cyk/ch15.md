소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 적용할 수 있는 해결 방법을 디자인 패턴이라고 부른다.

- 목적은 설계를 재사용 한느것이다.

디자인 패턴이 설계를 재사용하기 위한 것이라면 프레임워크는 설계와 코드를 함께 재사용하기 위한 것이다.

디자인 패턴과 프레임워크 모두 일관성 있는 협력과 관련 있다.

디자인 패턴은 특정 변경을 일관성 있게 다룰수 있는 `협력 템플릿`을 제공한다.

프레임워크는 특정한 변경을 일관성있게 다룰수 있는 `확장 가능한 코드 템플릿`을 제공한다.

패턴이란 무엇인가를 논의할때면 반복적으로 언급되는 몇가지 핵심적인 특징이 있다.

- 패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다.
- 패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며, 이 자식을 다른 사람과 의사소통 할 수 있다.
- 패턴은 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워주며 실질적인 코드 작성을 돕는다.
- 패턴의 요점은 패턴이 실무에서 탄생했다는 것이다.

패턴은 한 컨텍스트에서 유용한 동시에 다른 컨텍스트에서도 유용한 아이디어다.

일반적으로 패턴으로 인정하기 위한 조건으로 ’3의 규칙(rule of three)’를 언급한다.

- 이 규칙에 따르면 최소 세가지의 서로 다른 시스템에 특별한 문제 없이 적용할 수 있고, 유용한 경우에만 패턴으로 간주할 수 있다.

패턴은 경험을 통해 축적된 실무 지식을 효과적으로 요약하고 전달할 수 있다는 점이다.

- 따라서 경험이 적은 초보자도 패턴을 익히고 반복적으로 사용하는 과정에서 유연하고 품질 높은 소프트웨어를 개발하는 방법을 익힐 수 있다.

### 패턴 분류

패턴 분류 하는 가장 일반적인 방법은 범위나 적용 단계에 따라 아키텍처 패턴**,** 분석 패턴, 디자인 패턴, 이디엄의 4가지로 분류한다.

- 디자인 패턴(Design Pattern)
    - 특정 상황 내에서 일반적인 설계 문제를 해결하며 협력하는 컴포넌트들 사이에서 반복적으로 발생하는 구조를 서술한다
    - 특정한 설계문제를 해결하는 것을 목적으로 함
    - 프로그래밍 언어나 패러다임에 독립적이다
- 아키텍처 패턴 (Architecture Pattern)
    - 소프트웨어의 전체적인 구조를 결정하기 위해 사용
    - 미리 정의된 서브 시스템들을 제공하고 서브 시스템들의 책임, 관계를 조직화하는 규칙과 가이드를 제공한다
    - 프로그래밍 언어나 패러다임에 독립적이다
- 분석 패턴(Analysis Pattern)
    - 도메인 내의 개념적인 문제를 해결하는 데 초점을 맞춘다
    - 업무 모델링 시에 발견되는 공통적인 구조를 표현하는 개념들의 집합
- 이디엄(Idiom)
    - 특정 프로그래밍 언어에만 국한된 패턴이다
    - 주어진 언어의 기능/특성을 이용해 컴포넌트 간의 특정 측면을 구현하는 방법을 서술
        - C++에서는 객체가 스스로 자신을 참조하는 객체들의 개수를 카운트 해서 더 이상 자신이 참조되지 않으면 스스로를 삭제하는 COUNT POINTER라는 이디엄이 있다.
        - 하지만 JVM기반의 언어에서는 참조 되지 않은 객체들은 가비지 컬렉터에 의해 자동으로 삭제되기에 COUNT POINTER 이디엄은 유용하지 않다.


상위 정책은 상대적으로 변경에 안정적이지만 세부 사항은 자주 변경됨.

그래서 상위 정책이 세부사항에 의존하면 상위 정책이 필요한 모든 경우 세부 사항도 함께 존재해야 하기 때문에 재사용성이 낮아짐 → 의존성 역전 원칙에 맞게 상위, 세부 사항 모두 추상화에 의존하게 만든다.

핵심은 동일한 역할을 수행하는 객체 사이의 협력 구조를 다양한 애플리케이션에서 재사용하는것임.

이름 위해 변하는 것과 변하지 않는것을 분리해야 하는데 이는 서로 다른 주기로 배포 될 수 있도록 별도의 배포 단위로 분리해야 한다.

시작은 패키지로 분리하는 것이다.

![img.png](img.png)

- 상위 정책과 하위정책을 별도의 패키지로 분리

중요한것은 패키지 사이의 의존성이고 추상화에만 의존하도록 의존성의 방향을 조정하고 추상화를 경계로 분리했기 때문에 세부사항을 구현한 패키지는 항상 상위 정책을 구현한 패키지에 의존해야 한다.

### 제어 역전 원리

의존성 역전 월리는 프레임 워크의 가장 기본적인 설계 메커니즘이다.

의존성 역전은 의존성의 방향 뿐만 아니라, 제어 흐름의 주체 역시 역전 시킨다.

전통적인 구조에서는 상위 정책의 코드가 하부의 구체적은 코드를 호출한다. 그러나 의존성을 역전시킨 객체지향 구조에서는 반대로 프레임워크가 애플리케이션에 속하는 서브 클래스의 메서드를 호출한다.

따라서, 프레임워크를 사용할 경우 개별 애플리케이션에서 프레임워크로 제어 흐름의 주체가 이동한다. 제어 흐름의 주체 역시 역전 된다.