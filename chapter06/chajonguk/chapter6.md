# 메시지와 인터페이스

- 객체지향 애플리케이션의 가장 중요한 재료는 클래스가 아니라 객체들이 주고 받는 메시지다.
  - 클래스 사이의 정적인 관계에서 메시지 사이의 동적인 흐름으로 초점을 전환해야한다.
  - 애플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다.



- 협력과 메시지

  - 클라이언트-서버 모델
    - 협력은 어떤 객체가 다른 객체에게 무언가를 요청할 때 시작된다.
    - 객체가 다른 객체에게 접근할 수 있는 유일한 방법은 메시지를 전송하는 것 뿐이다.
    - 객체는 자신의 희망을 메시지라는 형태로 전송하고 메시지를 수신한 객체는 요청을 적절히 처리한 후 응답한다.
    - 두 객체 사이의 관계를 설명하기 위해 사용하는 전통적인 메타포는 클라이언트-서버 모델이다.
    - 협력 안에서 메시지를 전송하는 객체를 클라이언트, 메시지를 수신하는 객체를 서버라 부르며, 협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용이다.
  - 메시지와 메시지 전송
    - 메시지를 전송하는 객체를 메시지 전송자라고 부르고, 메시지를 수신하는 객체를 메시지 수신자라고 부른다.
    - 메시지는 오퍼레이션명과 인자로 구성되며 메시지 전송은 여기에 미시지 수신자를 추가한 것이다.
    - 예를 들어 `is_satisfied_by(screening)`은 오퍼레이션명(`is_satisfied_by`)과 인자(`screening`)으로 구성된 메시지이며, `condition.is_satisfied_by(screening)`는 메시지 수신자(`condition`)가 추가된 메시지 전송이다.
  - 메시지와 메서드
    - 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 메서드라고 부른다.
    - 기술적인 관점에서 객체 사이의 메시지 전송은 전통적인 방식의 함수 호출이나 프로시저 호출과는 다르다.
    - 전통적인 방식의 개발자는 어떤 코드가 실행될지를 정확하게 알고 있는 상황에서 함수 호출이나 프로시저 구문을 작성한다.
    - 즉 코드의 의미가 컴파일 시점과 실행 시점에 동일하다.
    - 반면에 객체는 메시지와 메서드라는 서로 다른 개념을 실행 시점에 연결해야 하기에 **컴파일 시점과 실행 시점의 의미가 달라질 수 있다.**
    - 메시지와 메서드의 구분은 메시지 전송자와 수신자가 느슨하게 결합될 수 있게 한다.



- 인터페이스와 설계 품질
  - 좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야한다.
    - 최소한의 인터페이스는 꼭 필요한 오퍼레이션만을 인터페이스에 포함한다.
    - 추상적인 인터페이스는 어떻게 수행하는지가 아니라 무엇을 하는지를 표현한다.
  - 위 조건을 만족시키는 가장 좋은 방법은 책임 주도 설계 방법을 따르는 것이다.
    - 책임 주도 설계는 메시지를 먼저 선택함으로써 협력과는 무관한 오퍼레이션이 인터페이스에 스며드는 것을 방지하여 인터페이스는 최소한의 오퍼레이션만 포함하게 된다.
    - 또한 메시지가 객체를 선택하게 함으로써 클라이언트의 의도를 메시지에 표현할 수 있게 하여 추상적인 오퍼레이션이 인터페이스에 자연스럽게 스며들게 된다.
  - 퍼블릭 인터페이스의 품질에 영향을 미치는 대표적인 원칙과 기법들은 아래와 같은 것들이 있다.
    - 디미터 법칙
    - 묻지 말고 시켜라
    - 의도를 드러내는 인터페이스
    - 명령-쿼리 분리



- 디미터 법칙(Law of Demeter)

  - 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 법칙이다.
    - 낯선 자에게 말하지 말라
    - 오직 인접한 이웃하고만 말하라.
  - 디미터 법칙을 따르게 위해서는 클래스가 특정한 조건을 만족하는 대상에게만 메시지를 전송하도록 프로그래밍해야 한다.
    - 모든 클래스 C와 C에 구현된 모든 메서드 M에 대해서, M이 메시지를 전송할 수 있는 모든 객체는 다음에 서술된 클래스의 인스턴스여야 한다(이때 M에 의해 생성된 객체나 M이 호출하는 메서드에 의해 생성된 객체, 전역 변수로 선언된 객체는 모두 M의 인자로 간주한다).
    - M의 인자로 전달된 클래스(C 자체를 포함) 또는 C의 인스턴스 변수의 클래스
  - 디미터 법칙과 캡슐화
    - 디미터 법칙은 캡슐화를 다른 관점에서 표현한 것이다.
    - 디미터 법칙이 가치 있는 이유는 캡슐화를 위해 따라야 하는 구체적인 지침을 제공하기 때문이다.
    - 캡슐화가 클래스 내부 구현을 감춰야한다는 사실을 강조한다면 디미터 법칙은 협력하는 클래스의 캡슐화를 지키기 위해 접근해야 하는 요소를 제한한다.
  - 무비판적으로 디미터 법칙을 수용하면 인터페이스 관점에서 객체의 응집도가 낮아질 수 있다.



- 묻지 말고 시켜라(Tell, Don't Ask)

  - 디미터 법칙은 훌륭한 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다는 사실을 강조한다.
    - 묻지 말고 시켜라는 이런 스타일의 메시지 작성을 장려하는 원칙을 가리키는 용어다.
    - 메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안 된다.
    - 객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반한다.

  - 묻지 말고 시켜라 원칙을 따르면 밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들 수 있다.
    - 객체지향의 기본은 변경될 확률이 높은 정보와 행동을 하나의 단위로 통합하는 것이다.
    - 묻지 말고 시켜라 원칙을 따르면 객체의 정보를 이용하는 행동을 객체의 외부가 아닌 내부에 위치시키기 때문에 자연스럽게 정보와 행동을 동일한 클래스 안에 두게 된다.



- 의도를 드러내는 인터페이스(Intention Revealing Interface)

  - 메서드가 무엇을 수행하는지를 나타내도록 이름을 지어야 한다.
  - 이 방식은 객체가 협력 안에서 수행하는 책임에 관해 고민하도록 한다.



- 원칙의 함정

  - 위에서 살펴본 것들은 절대적인 법칙이 아닌 원칙이다.

  - 원칙들이 서로 충돌하는 경우에도 원칙에 정당성을 부여하고 억지로 끼워 맞춰서는 안 된다.
  - 원칙이 현재 상황에 부적합하다고 판단된다면 과감하게 원칙을 무시해야한다.
