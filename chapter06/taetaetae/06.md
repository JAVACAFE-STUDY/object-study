# 6. 메시지와 인터페이스

- 애플리케이션은 클래스로 구성되지만 메시지를 통해 정의함
- 객체가 수신하는 메시지들이 객체의 퍼블릭 인터페이스로 구성
    - 유연하고 재사용 가능한 퍼블릭 인터페이스를 만드는에 설계 원칙과 기법을 익혀야 함

## **01. 협력과 메시지**

- **클라이언트-서버 모델**
    - 클라이언트 : 협력 안에서 메시지를 **전송**하는 객체
    - 서버 : 메시지를 **수신**하는 객체
    - 협력 : 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용
- **메시지와 메시지 전송**
    - 메시지 : 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단(오퍼레이션명, 인자로 구성)
    - 메시지 전송(패싱) : 한 객체가 다른 객체에게 도움을 요청하는 것(메시지 수신자, 오퍼레이션명, 인자로 구성)
    - 메시지 전송자 : 메시지를 전송하는 객체
    - 메시지 수신자 : 메시지를 수신하는 객체
    - JAVA -> 수신자.오퍼레이션명(인자) -> condition.isSatisfiedBy(screening)
- **메시지와 메서드**
    - 메서드 : 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저
    - 메시지 전송자 : 자신이 어떤 메시지를 전송해야 하는지 알면 됨
    - 메시지 수신자 : 필요한 메서드를 자유롭게 결정
- **퍼블릭 인터페이스와 오퍼레이션**
    - 퍼블릭 인터페이스 : 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합
    - 오퍼레이션 : 수행 가능한 어떤 행동에 대한 추상화(퍼블릭 인터페이스에 포함된 메시지)
    - 메서드 : 오퍼레이션을 구현
    - 메시지 전송하면 오퍼레이션을 호출하는 것이고 적절한 메서드를 찾아 실행
- **시그니처**
    - 시그니처 : 오퍼레이션명(메서드)과 파라미터 목록의 합
    - 다형성 : 동일한 오퍼레이션 호출에 대한 서로 다른 메서드들이 실행

## **02. 인터페이스와 설계 품질**

- 협력을 설계하고 객체가 수신할 메시지를 결정할 때 퍼블릭 인터페이스의 품질 향상에 미치는 원칙과 기법
- **디미터 법칙**
    - 디미터 법칙 : 협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제로 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제안 함
    - 클래스 내부의 메서드가 아래 조건을 만족하는 인스턴스에만 메시지 전송하도록 해야 함
        - this 객체
        - 메서드의 매개변수
        - this의 속성
        - this의 속성인 컬렉션의 요소
        - 메서드 내에서 생성된 지역 객체
    - 클래스의 캡슐화를 지키기 위해 접근해야 하는 요소를 제한함
    - 수신자에게 어떤 메시지가 더 좋은 메시지인지 알려줌
- **묻지 말고 시켜라**
    - 묻지 말고 시켜라 원칙 -> 객체의 정보를 이용하는 행동을 객체의 외부가 아닌 내부에 위치시킴
    - 정보 전문가에게 책임을 할당하게 되고 높은 응집도를 가진 클래스를 얻음
- **의도를 드러내는 인터페이스**
    - 구현과 관련된 모든 정보를 캡슐화하고 객체의 퍼블릭 인터페이스에는 협력과 관련된 의도만을 표현
    - 의도를 드러내는 선택자(메서드를 명명하는 방법)
        - 메서드가 작업을 어떻게 수행하는지
        - '어떻게'가 아니라 '무엇'을 하는지를 알려 줘야 함 -> 메서드의 내부 구현을 설명하는 이름
    - 객체에게 묻지 말고 시키되 구현 방법이 아닌 클라이언트의 의도를 드러내야 함
- **함께 모으기**
    - 디미터 법칙 -> 객체 간의 협력을 설계할 때 캡슐화를 위반하는 메시지가 인터페이스에 포함되지 않도록 제한
    - 묻지 말고 시켜라 원칙 -> 디미터 법칙을 준수하는 협력을 만들기 위해 스타일 제시
    - 의도를 드러내는 인터페이스 원칙 -> 객체의 퍼블릭 인터페이스에 어떤 이름이 드러내야 하는지에 대한 지킴을 제공

## **03. 원칙의 함정**

- 디미터 법칙과 묻지 말고 시켜라 원칙은 객체의 퍼블릭 인터페이스를 깔끔하고 유연하게 만들 수 있는 훌륭한 설계 원칙이지만 예외는 존재
- **디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다**
    - InStream.of(1, ,15, 20, 3, 9).filter(x -> x > 10).distinct().count();
        - InStream의 인스턴스를 또 다른 InStream의 인스턴스로 변환
        - 하나 이상의 도트(.)를 사용하는 것이 디미터 법칙은 위반하는 것이 아님
- **결합도와 응집도의 충돌**
    - 객체는 내부 구조를 숨겨야 하므로 디미터 법칙을 따르는 것이 좋지만 자료 구조라면 당연히 내부를 노출해야 하므로 디미터 법칙을 적용할 필요가 없음

## **04. 명령-쿼리 분리 원칙(Command-Query Seqparation)**

- 명령-쿼리 분리 원칙 : 오퍼레이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야 함
    - 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 좋음
    - 객체의 상태를 변경하는 명령은 반환값을 가질 수 없음
    - 객체의 정보를 반환하는 쿼리는 상태를 변경 할 수 없음
- 루틴 : 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈
    - 프로시저 : 정해진 절차에 따라 내부의 상태를 변경하는 루틴(부수효과 O, 반환값 X)
    - 함수 : 어떤 절차에 따라 필요한 값을 계산하여 반환하는 루틴(부수효과 X, 반환값 O)
- 부수효과 -> side effect -> 부작용 -> 외부에 영향을 끼치는 경우
- 인터페이스 측면에서 프로시저(명령)와 함수(쿼리)
    - 명령 : 객체의 상태를 수정하는 오퍼레이션
    - 쿼리 : 객체와 관련된 정보를 반환하는 오퍼레이션
- **반복 일정의 명령과 쿼리 분리하기**
    - 도메인 이벤트(Event가), 반복 일정(RecurringSchedule)
        - 이벤트 -> 특정 일자에 실제로 발생하는 사건
            - 19년 5월 8일 수요일 10시~11시까지 회의
        - 반복 일정 -> 일주일 단위로 돌아오는 특정 시간 간격에 발생하는 사건 전체
            - 매주 수요일 10시~11시까지 회의 반복
- isSatisfied 메서드 오류
    - reschedule 메서드를 호출하는 isSatisfied 메서드는 Event가 RecurringSchedule에 설정된 조건을 만족하지 못할 경우 Event의 상태를 조건을 만족시키도록 변경한 후 false를 반환
        - 19년 5월 9일 일어나는 Evnet는 매주 수요일 마다 반복적으로 발생하는 일정 RecurringSchedule에 전달할 경우 19년 5월 8일로 변경되고 반환 값을 false가 반환
- isSatisfied 메서드 버그를 찾기 어려웠던 이유는 명령과 쿼리의 두 가지 역할을 수행 했기 때문
    - isSatisfied 메서드는 Event가 RecurringSchedule의 조건에 부합하는지를 판단한 후 ture, false를 반환 -> 쿼리
    - isSatisfied 메서드는 Event가 RecurringSchedule의 반환값이 false 경우 Event의 상태를 조건에 부합하도록 변경 ->부수효과를 가지는 명령
- **명령-쿼리 분리와 참조 투명성**
    - 참조 투명성 -> 어떤 표현식 e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성
        - f(1) + f(1) = 6 -> 3 + 3 = 6
        - f(1) * 2 = 6 -> 3 * 2 = 6
        - f(1) - 1 = 2 -> 3 - 1 = 2
    - 참조 투명성 장점
        - 모든 함수를 이미 알고 있는 하나의 결괏값으로 대체 할 수 있기 때문에 식이 쉽게 계산할 수 있음
        - 모든 곳에서 함수의 결괏값이 동일하기 때문에 식의 순서를 변경하더라도 각 식의 결과는 달라지지 않음
    - 명령형 프로그래밍과 함수형 프로그래밍
        - 명령형 프로그래밍 -> 부수효과를 기반으로 하는 프로그래밍
            - 상태를 변경시키는 연산들을 적절한 순서대로 나열함
            - 메시지에 의한 객체의 상태 변경에 집중하는 객체지향 프로그래밍 언어로 분류
        - 함수형 프로그래밍 -> 부수효과가 존재하지 않는 수학적인 함수에 기반
            - 참조 투명성의 극대화
            - 실행결과를 이해하고 예측하기 쉬움
            - 하드웨어 발달로 병렬 처리가 중요하므로 대세로 상승
            - 객체지향 언어들을 함수형 프로그래밍 패러다임에 접목 시킴
- **책임에 초점을 맞춰라**
    - 위 원칙을 설계 방법
        - 메시지를 먼저 선택하고 그 후에 메시지를 처리할 객체를 선택
        - 명령과 쿼리를 분리하고 계약에 의한 설계 개념을 통해 객체의 협력 방식을 명시적으로 드러내는 것
        - 객체의 구현 이전에 객체 사이의 협력에 초점을 맞추고 협력 방식을 단순하고 유연하게 만드는 것
    - 메시지를 먼저 선택하는 방식
        - 디미터 법칙
            - 협력이라는 컨텍스트 안에서 객체보다 메시지를 먼저 결정하면 두 객체 사이의 구조적인 결합도를 낮춤 -> 메시지가 객체를 선택
        - 묻지 말고 시켜라
            - 메시지를 먼저 선택하면 협력을 구조화 하게 됨
        - 의도를 드러내는 인터페이스
            - 메시지 이름에서 무엇을 원하는지가 보임
        - 명령-쿼리 분리 원칙
            - 협력이라는 문맥 안에서 객체의 인터페이스에 관해 고민하는 것을 의미 -> 협력 속에서 객체의 상태를 예측하고 이해하기 쉽게 만듬
