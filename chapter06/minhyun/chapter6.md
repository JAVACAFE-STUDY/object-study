- 애플리케이션이 클래스의 집합으로 구성 된다는 것은 오해이다. 클래스에 집착하지말고 객체를 지향하자.
    - 객체지향 app의 가장 중요한 재료는 클래스가 아닌 객체들이 주고받는 메시지이다.

# 01. 협력과 메시지

## 클라이언트-서버 모델

- **클라이언트**
    - 메시지를 전송하는 객체
- 서**버**
    - 메시지를 수신하는 객체

→ 단방향 상호작용

## 메시지와 메시지 전송

- **메시지**
    - 객체들이 협력하기 위해 사용하는 유일한 의사소통 수단
    - 오퍼레이션명과 인자로 구성
- **메시지 전송 / 메시지 패싱**
    - 한 객체가 다른 객체에게 도움을 요청하는 것
    - 메시지 전송의 경우 메시지(오퍼레이션, 인자) + 메시지 수신자로 구성

## 메시지와 메서드

- **메서드**
    - 메시지를 수신 했을 때 실제 실행되는 함수 혹은 프로시저

코드의 의미가 컴파일 시점과 런타임 시점에 동일한 전통적 방식과 달리, **객체지향 방식은 메시지와 메서드라는 서로 다른 개념을 런타임 시점에 연결하기 때문에 컴파일과 런타임 시점의 의미가 달라질 수 있음.**

→ 느슨한 결합을 통해 유연하고 확장가능한 코드 작성 가능

## 퍼블릭 인터페이스와 오퍼레이션

- **퍼블릭 인터페이스**
    - 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합
- **오퍼레이션**
    - 퍼블릭 인터페이스에 포함된 메시지 → 수행 가능한 어떤 행동에 대한 추상화
    - 실행하기 위해 객체가 호출될 수 있는 변환이나 정의에 관한 명세 (UML 공식 정의)
- **메서드**
    - 오퍼레이션에 대한 구현

## 시그니처

오퍼레이션의 이름과 파라미터 목록을 합친 것.

- 오퍼레이션 → 실행 코드 없이 시그니처만을 정의한 것
- 메서드 → 시그니처에 구현을 더한 것

**객체의 퍼블릭 인터페이스가 객체의 품질을 경정하기 때문에 결국 메시지가 객체의 품질을 결정함.**

# 02. 인터페이스와 설계 품질

### **좋은 인터페이스의 조건**

- 최소한의 인터페이스
- 추상적인 인터페이스

→ 구현하는 가장 좋은 방법은 책임 주도 설계 방법을 따르는 것

*하기 명시되는 원칙과 기법은 퍼블릭 인터페이스의 품질에 영향을 미친다.*

## 디미터 법칙

> **- 이름의 유래**
디미터라는 이름의 프로젝트를 진행하던 중 객체들의 협력 경로 제한시 결합도를 효과적으로 낮출 수 있다는 사실 발견
> 

- 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라.
    
    → 오직 인접한 이웃하고만 말하라 (코드상으로 오직 하나의 도트만 사용하라)
    
- 아래 조건을 만족하는 인스턴스에만 메시지를 전송하도록 한다.
    - this 객체
    - 메서드의 매개변수
    - this의 속성
    - this의 속성인 컬렉션의 요소
    - 메서드 내에서 생성된 지역 객체

이를 위반하는 설계는 ‘인터페이스와 구현의 분리 원칙’ 을 위반하는 것과 같다.

→ 요구사항에 취약해짐.

## 묻지말고 시켜라 (= 디미터 법칙)

- 객체의 정보를 이용하는 행동을 객체의 외부가 아닌 내부에 위치시켜 정보와 행동을 동일한 클래스 안에 둠.
- 상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체하여 인터페이스를 향상시켜라.

## 의도를 드러내는 인터페이스

구현과 관련된 모든 정보를 캡슐화 하고 객체의 퍼블릭 인터페이스엔 협력과 관련된 의도많을 표현해야 한다는 것.

### 메서드를 명명하는 두가지 방법

1. 메서드가 작업을 어떻게 수행하는지를 나타내도록
2. ‘어떻게’ 가 아니라 ‘무엇’을 하는지를 드러내도록
    
    → 해당 패턴을 ‘의도를 드러내는 선택자(Intention Revealing Selector)’ 라고 부름
    

## 함께 모으기

코드 예시.

# 03. 원칙의 함정

**설계는 트레이드오프의 산물이라는 것을 잊지 말라.**

→ 적절하게 트레이드오프 할 수 있는 능력을 가지는 것이 고수다.

- 메서드 체이닝이 모두 디미터 법칙을 위반하는 것은 아니다.
    - 위반되는 것은 내부 구조가 외부로 노출되는 경우로 한정된다.

## 결합도와 응집도의 충돌

일반적으로 어떤 객체의 상태를 물어본 후 반환된 상태를 기반으로 결정을 내리고, 그 결정에 따라 객체의 상태를 변경하는 코드는 ‘묻지말고 시켜라’ 스타일로 변경해야 한다.

→ 그러나 무작정 위임 메서드를 추가하면 상관없는 책임들을 한꺼번에 떠 안을 수 있기 때문에 잘 체크해야함.

<클린코드> 에서 **디미터 법칙의 위반여부는 ‘묻는 대상이 객체인지, 자료구조인지에 달려있다’ 고 설명**

→ 객체는 내부 구조를 숨겨야하므로 디미터 법칙을 따르는 것이 좋으나, 자료구조면 내부 노출이 당연하기 때문에 법칙을 적용할 필요가 없다.

***“경우에 따라 다르다” → 무조건 명심하라***

# 04. 명령-쿼리 분리 원칙 (Command-Query Separation)

- **루틴(routine)**
    - 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈
    - 프로시저와 함수로 구분됨.

- **프로시저**
    - 정해진 절차에 따라 내부의 상태를 변경하는 루틴의 한 종류
    - 부수효과를 발생시킬 수 있지만 값을 반환할 수 없다.
- **함수**
    - 어떤 절차에 따라 필요한 값을 계산해서 반환하는 루틴의 한 종류
    - 값을 반환할 수 있지만 부수효과를 발생시킬 수 없다.

객체의 인터페이스 측면에서 프로시저와 함수를 부르는 또 다른 이름 → 명령과 쿼리

- 명령(Command)
    - 객체의 상태를 수정하는 오퍼레이션 (= 프로시저)
    - 반환값을 가질 수 없다.
- 쿼리(Query)
    - 객체와 관련된 정보를 반환하는 오퍼레이션 (= 함수)
    - 상태를 변경할 수 없다.

## 반복 일정의 명령과 쿼리 분리하기

- 이벤트
    - 특정 일자에 실제로 발생하는 사건
- 반복 일정
    - 특정 시간 간격에 발생하는 사건 전체

명령과 쿼리가 뒤섞인다면 실행 결과를 예측하기가 어려워질 수 있다.

내부적으로 부수효과를 가지는 메서드의 사이드 이펙트를 없애는 해결책은 명령과 쿼리를 명확하게 분리하는것이다.

## 명령-쿼리 분리와 참조 투명성

- 명령과 쿼리를 분리함으로써, 참조 투명성의 장점을 제한적이나마 누릴 수 있다.

### 참조 투명성

- 어떤 표현식 e가 있을때, 모든 e를 e의 값으로 바꾸더라도 결과가 달라지지 않는 특성 (=수학 체계)
- e.g.) 수학의 함수

- **장점**
    - 모든 함수를 이미 알고 있는 하나의 결괏값으로 대체할 수 있기 때문에 쉬운 식 계산 가능
    - 모든 곳에서 함수의 결괏값이 동일하여 식의 순서를 변경하더라도 각 식의 결과는 불변

### 불변성

- 어떤 값이 불변한다는 말은 부수효과가 발생하지 않는다는 말과 동일 (=불변성)

**→ 불변성은 부수효과의 발생을 방지하고 참조 투명성을 만족시킨다.**

### 명령형 프로그래밍과 함수형 프로그래밍

**명령형 프로그래밍**

- 상태를 변경시키는 연산들을 적절한 순서대로 나열함으로써 프로그램을 작성

**함수형 프로그래밍**

- 부수효과가 존재하지 않는 수학적 함수에 기반

## 책임에 초점을 맞춰라

- 디미터 법칙
- 묻지말고 시켜라
- 의도를 드러내는 인터페이스
- 명령-쿼리 분리 원칙

훌륭한 메시지를 얻기 위한 출발점은 책임 주도 설계 원칙을 따르는 것.

위 원칙들은 협력을 위해 두 객체가 보장해야 하는 실행시점의 제약을 인터페이스에 명시할 수 있는 방법이 없음

→ 계약에 의한 설계 개념 제안 (= 클라와 서버가 준수해야 하는 제약을 코드상에 명시적으로 표현하고 강제함)