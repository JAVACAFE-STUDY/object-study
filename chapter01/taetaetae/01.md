# 01. 객체, 설계
- 모든 소프트웨어 모듈의 세 가지 목적
  - 실행 중에 제대로 동작
  - 변경을 위해 존재, 변경이 가능해야 함
  - 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 함
- 예시에서 > 각 객체들이 통제받는, 수동적인 존재라는 문제
- 이해 가능한 코드란? 그 동작이 우리의 예상에서 크게 벗어나지 않는 코드
- 변경에 취약한 코드
  - 지나치게 세부적인 사실에 의존해서 동작하는 게 문제
  - 우리의 목표는 애플리케이션의 기능을 구현하는 데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거하는 것
  - 객체 사이의 의존성이 과한 경우를 가리켜 "결합도가 높다"라고 표현
- 예시에서 > 각 객체들의 정보에 대해 너무 세세한 부분까지 알지 못하도록 정보를 차단
- 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 캡슐화라고 부른다.
- 인터페이스(interface)에만 의존, 인터페이스를 포함하고 있다는 건 구현(implementation)의 영역에 속함
- 내부 구현을 외부에 노출하지 않고 자신의 문제를 스스로 책임지고 해결하는 것 == 자율적인 존재가 되는 것
- 캡슐화와 응집도
  - 핵심은 객체의 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것
  - 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도가 높다고 말함
  - 외부의 간섭을 최대한 배제하고 메시지를 통해서만 협력
- 절차적 프로그래밍 방식 == 전형적인 의존성 구조
- 변경을 버그를 부르고 버그에 대한 두려움은 코드를 변경하기 어렵게 만듦 (그래서 절차적 프로그래밍이 코드를 어렵게 양산하는 경향)
- 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍 방식을 "객체지향 프로그래밍"
- 객체지향 코드는 자신의 문제를 스스로 처리해야 한다는 우리의 예상을 만족시켜주기 때문에
  - 이해하기 쉽고
  - 객체 내부의 변경이 객체 외부에 파급되지 않도록 제어할 수 있기 때문에
  - 변경하기가 쉽다.
- 책임 관점
  - 절차적 프로그래밍 : 중앙 집중
  - 객체지향 프로그래밍 : 분산
- 객체지향 프로그래밍을 흔히 데이터와 프로세스를 하나의 단위로 통합해 놓는 방식
- 객체지향 설계의 핵심은 적절한 객체에 적절한 책임을 할당하는 것
- 훌륭한 설계는 적절한 트레이드오프의 결과물이라는 사실을 명심
- 비록 현실에서는 수동적인 존재라고 하더라도 일단 객체지향의 세계에 들어오면 모든 것이 능동적이고 자율적인 존재로 바뀐다.
- 우리는 오늘 완성해야 하는 기능을 구현하는 코드를 짜야 하는 동시에 내일 쉽게 변경할 수 있는 코드를 짜야 한다.
- 객체들 사이의 상호작용은 객체 사이에 주고받는 메시지로 표현됨
