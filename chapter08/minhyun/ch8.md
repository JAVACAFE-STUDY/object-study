작고 응집도 높은 객체 → 책임의 초점이 명확하고 한 가지 일만 잘하는 객체

# 01. 의존성 이해하기

## 변경과 의존성

- **실행시점**
    - 의존되는 객체가 정상적으로 동작하기 위해서 실행 시 의존 대상 객체가 반드시 존재해야 함.
- **구현 시점**
    - 의존 대상 객체가 변경될 경우 의존 객체도 함께 변경됨.

객체가 예정된 작업을 정상적으로 수행하기 위해 **다른 객체를 필요로 하는 경우 두 객체 사이에 의존성이 존재한다고 말한다.**

- 의존성은 방향성을 가지며 항상 단방향이다.
- 의존성은 변경에 의한 영향의 전파 가능성을 암시한다.

## 의존성 전이

- 의존성이 실제로 전이될지 여부는 변경의 방향과 캡슐화의 정도에 따라 달라진다.
    - 내부구현을 효과적으로 캡슐화되어 있다면 변경이 전파되지 않을 것.

- **직접 의존성**
    - 한 요소가 다른 요소에 직접 의존하는 경우
- **간접 의존성**
    - 직접적인 관계는 존재하지 않지만 의존성 전이에 의해 영향이 전파되는 경우

## 런타임 의존성과 컴파일 타임 의존성

- 런타임: 애플리케이션이 실행되는 시점
- 컴파일 타임: 작성된 코드를 컴파일 하는 시점 or 문맥에 따라선 코드 그 자체

***객체지향 애플리케이션에서…***

‘런타임’의 주인공은 ‘객체’ 

→ 런타임 의존성이 다루는 주제는 객체 사이의 의존성

‘컴파일’의 주인공은 ‘클래스’ 

→ 컴파일타임 의존성이 다루는 주제는 클래스 사이의 의존성

**유연하고 재사용 가능한 설계를 창조하기 위해선 동일한 소스코드 구조를 가지고 다양한 실행 구조를 만들 수 있어야 한다.**

- 어떤 클래스의 인스턴스가 다양한 클래스의 인스턴스와 협력하기 위해선 협력할 인스턴스의 구체적 클래스를 알아선 안된다. → 런타임에 해결해야 함.

## 컨텍스트 독립성

- 유연하고 확장 가능한 설계를 만들기 위해선 컴파일타임 의존성과 런타임 의존성이 달라야한다.
- 구체적인 클래스를 알수록 그 클래스가 사용되는 특정한 문맥에 강하게 결합되기 때문에 협력 객체의 구체적 클래스에 대해 알아선 안된다.

- 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해지고 이를 ‘컨텍스트 독립성’이라고 한다.

## 의존성 해결하기

- 컴파일 타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 ‘의존성 해결’ 이라고 부른다. 일반적으로 3가지방법이 있다.
    1. 객체를 생성하는 시점에 생성자를 통해 의존성 해결
    2. 객체 생성 후 setter 메서드를 통해 의존성 해결
    3. 메서드 실행 시 인자를 이용해 의존성 해결

# 02. 유연한 설계

## 의존성과 결합도

- 의존성은 ‘재사용성’과 관련이 있다.
    - 컨텍스트에 독립적인 의존성은 바람직한 의존성임.
    - 특정 컨텍스트에 강하게 결합된 의존성은 바람직하지 않은 의존성임.

→ 느슨하거나 약한 결합도를 가져야 한다.

## 지식이 결합을 낳는다.

- 서로에 대해 알고 있는 지식의 양이 결합도를 결정한다.
- 결합도를 느슨하게 만들기 위해선 협력 대상에 대해 필요한 정보 외엔 최대한 감추는 것이 중요하다. → 추상화

## 추상화에 의존하라

- **추상화**
    - 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법

- 추상화와 결합도의 관점에서 의존 대상을 다음과 같이 구분한다. (아래로 갈수록 느슨한 결합도를 가진다)
    - 구체 클래스 의존성
    - 추상 클래스 의존성
    - 인터페이스 의존성

## 명시적인 의존성

- 의존성은 명시적으로 표현되어야 한다.
- 의존성을 구현 내부에 숨겨두지 말아라.
- 유연하고 재사용 가능한 설계란 퍼블릭 인터페이스를 통해 의존성이 명시적으로 드러나는 설계이다.
- 경계해야할 것은 의존성 자체가 아니라 의존성을 감추는 것이다 → 숨겨져 있는 의존성을 밝은 곳으로 드러내어 널리 알리자.

- 의존성이 명시적이지 않으면 의존성을 파악하기 위해 내부 구현을 직접 보아야함.
    
    → 고통스러움…
    

## new는 해롭다

- new 연산자를 사용시 구체 클래스의 이름을 직접 기술해야 함.
    - 구체 클래스에 의존할 수 밖에 없기 떄문에 결합도가 높아짐.
- new 연산자는 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 함.
    - 클라이언트가 알아야하는 지식의 양이 늘어나기 때문에 결합도가 높아짐.

**해결 방법은 인스턴스를 생성하는 로직과 생성된 인스턴스를 사용하는 로직을 분리하는 것.**

→ 생성의 책임을 클라이언트로 옮긴다.

***훌륭한 설계란..***

- 사용과 생성의 책임을 분리
- 의존성을 생성자에 명시적으로 드러냄
- 구체 클래스가 아닌 추상 클래스에 의존하게 함
- 객체를 생성하는 책임을 객체 내부가 아닌 클라이언트로 옮김

## 가끔은 생성해도 무방함

생성자를 체인처럼 연결하여 사용한다. (⇒ 오버로딩 할 때도 사용가능)

(첫번째 생성자에서 두번째 생성자를 ‘this’로 호출하여 구체 클래스를 다르게 삽입)

## 표준 클래스에 대한 의존은 해롭지 않다

의존성이 불편한 이유는 변경에 대한 영향을 암시하기 때문인데, 변경될 확률이 거의 없는 클래스라면 의존성이 문제가 되지 않는다.

(e.g. JDK에 포함된 표준 클래스)

해당 클래스들은 구체 클래스에 의존하거나 직접 인스턴스를 생성하더라도 문제가 없다.

---

- 유연하고 재사용 가능한 설계는 작은 객체들의 행동을 조합함으로써 새로운 행동을 이끌어 낼 수 있는 설계.
- 훌륭한 객체지향 설계란 객체가 어떻게 하는질 표현하는 것이 아니라 객체들의 조합을 선언적으로 표현함으로써 객체들이 무엇을 하는지 표현하는 설계.
- 이런 설계를 창조하는데 핵심은 의존성을 관리하는 것.