# 의존성 관리하기

## 변경과 의존성

어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때 두 객체 사이에 의존성이 존재하게 된다. 의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가진다.

- 실행 시점: 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
- 구현 시점: 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.

## 의존성 전이

의존성은 전이될 수 있다. 

```
PeriodCondition -> Screening -> Movie
```

의존성 전이에 의해 잠재적으로 PeriodCondition은 Movie에 의존한다. 의존성의 종류는 직접 의존성, 간접 의존성으로 나눈다.

## 런타임 의존성과 컴파일타임 의존성

- 런타임: 애플리케이션이 실행되는 시점
- 컴파일타임: 작성된 코드를 컴파일하는 시점, 또는 코드 그 자체

## 컨텍스트 독립성

유연하고 확장 가능한 설계를 만들기 위해서는 컴파일타임 의존성과 런타임 의존성이 달라야한다. 클래스는 자신과 협력할 객체의 구체적인 클래스에 대해 알아서는 안 된다.
구체적인 클래스를 알면 알수록 그 클래스가 사용되는 특정한 문맥에 강하게 결합되기 때문이다.

설계가 유연해지기 위해서는 가능한 한 자신이 실행될 컨텍스트에 대한 구체적인 정보를 최대한 적게 알아야 한다.

## 의존성 해결하기

- 생성자
- setter
- 메서드 인자

## 의존성과 결합도

구체적인 클래스에 의존하게 되면 다른 종류의 할인 정책이 필요한 문맥에서 Movie를 재사용할 수 있는 가능성을 없앤다.

바람직한 의존성은 재사용성과 관련이 있다. 

## 추상화에 의존하라

구체 클래스 -> 추상 클래스 -> 인터페이스

추상 클래스를 의존하더라도 클래스 상속 계층이 무엇인지에 대해서는 알고 있어야함. 인터페이스에 의존하면 상속 계층을 모르더라도 어떤 메시지를 수신할 수 있는지에 대한 지식만을 남기기 때문에 추상 클래스 의존성보다 결합도가 낮다.

## new는 해롭다

new는 결합도를 높히기 때문에 해롭다. 인스턴스를 생성하기 위해 어떤 인자들이 필요하고 그 인자들을 어떤 순서로 사용해야 하는지에 대한 정보도 노출시킬뿐만 아니라 인자로 사용되는 구체 클래스에 대한 의존성을 추가한다.

해결 방법은 인스턴스를 생성하는 로직과 인스턴스를 사용하는 로직을 분리하는 것이다. 사용과 생성의 책임을 분리하면 설계를 유연하게 만들 수 있다.

