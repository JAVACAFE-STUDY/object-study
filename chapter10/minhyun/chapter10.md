## 1. 알게된 점, 배운 점

- 중복 여부를 판단하는 기준은 변경에 반응하는 방식(e.g. 변경시 두 코드를 함께 수정해야 함) → 코드의 모양이 유사하단 건 중복의 징후일 뿐.

- DRY(Don’t Repeat Yourself) 원칙 == Once and Only Once 원칙 == 단일 지점 제어 원칙 == 코드 안에 중복 존재 X

- **상속을 위한 경고 (e.g. 취약한 기반 클래스 문제)**
    1. 강결합을 주의 → `super` 호출을 제거할 수 있는 방법을 찾아 결합도 제거
    2. 부모클래스의 메서드가 자식 클래스의 내부 구조 규칙을 깨뜨릴 수 있다.
        - 불필요한 인터페이스 상속(stack과 vector의 관계, Hashtable과 Properties의 관계)
    3. 자식 클래스가 부모 클래스의 메서드를 오버라이딩 할 경우 부모 클래스가 본인 메서드를 사용할 때 자식 클래스가 결합될 수 있음.
        - 메서드 오버라이딩의 오작용 (InstrumentedhHashset과 hashSet의 관계)
    4. 결합도로 인해 부모,자식의 구현을 영원히 변경하지 않거나, 동시에 변경하거나 택1할 수 밖에 없다.

- 상속에 의한 피해 최소화
    1. 자식클래스가 부모 클래스의 구현이 아닌 추상화에 의존하도록 하자.
    2. 객체 생성 로직에 대한 변경을 막기 보다는 핵심 로직의 중복을 막아라.
    3. 핵심로직은 한 곳에 모아놓고 조심스럽게 캡슐화 하되, 공통적 핵심 로직은 최대한 추상화 해야한다.

- 차이에 의한 프로그래밍: 기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법
    - 목표: 중복 코드를 제거하고 코드를 재사용하는 것

- 상속은 코드 재사용 측면에서 아주 강력한 도구이나, 오용과 남용이 자주 일어날 수 있다. 정말로 필요한 경우에만 상속을 사용하고 **‘합성’을 주로 사용**하자.

## 2. 궁금한 점

- p327의 addAll쪽 더해지는 부분, 그럼 `super.addAll()`로 부모객체의 `addAll()` 을 실행하도록 했으나 실행의 주체가 `Instru~hashSet` 이기때문에 부모의 `add` 를 쓰는게 아니고 자식의 `add`를 써서 처리된다는건지?
    - 아직도 기초를 헷갈리는구만.. (`super.addAll`에서는 `add`를 for를 통해 3번 실행하도록 하였음)
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/34ea7cb7-d202-4e90-926d-07b7bc241167/715ad157-6ffc-47e1-923a-91abf8ce2817/Untitled.png)
    

## 3. 같이 논의해보고 싶은 내용, 공유하고 싶은 내용