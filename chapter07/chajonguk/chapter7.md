# 객체 분해

- 분해
  - 추상화
    - 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업을 의미한다.
    - 본질적인 정보만 남기고 불필요한 세부 사항을 걸러냄으로써 문제를 단순화할 수 있게 해준다.
  - 분해는 큰 문제를 해결 가능한 작은 문제로 나누는 추상화 기법을 의미한다.
  - 객체지향 패러다임에서의 분해
    - 객체지향 패러다임은 역할과 책임을 수행하는 자율적인 객체들의 공동체를 구축하는 것이다.
    - 여기서 역할과 책임을 수행하는 객체가 객체지향 패러다임이 이용하는 추상화다.
    - 기능을 협력하는 공동체를 구성하도록 객체들로 나누는 과정이 객체지향 패러다임에서의 분해를 의미한다.



- 메인 함수로서의 시스템

  - 프로시저

    - 프로시저는 반복적으로 실행되거나 거의 유사하게 실행되는 작업들을 하나의 장소에 모아놓음으로써 로직을 재사용하고 중복을 방지할 수 있는 추상화 방법이다.
    - 프로시저를 추상화라고 부르는 이유는 내부의 상세한 구현 내용을 모르더라도 인터페이스만 알면 프로시저를 사용할 수 있기 때문이다.
    - 따라서 프로시저는 잠재적으로 정보 은닉의 가능성을 제시하지만, 프로시저만으론 정보은닉 체계를 구축하는 데는 한계가 있다.

  - 기능 분해

    - 기능은 오랜 시간 동안 시스템을 분해하기 위한 기준으로 사용됐다.
    - 이 같은 시스템 분해 방식을 알고리즘 분해 또는 기능 분해라고 부른다.

    - 기능 분해의 관점에서 추상화의 단위는 프로시저이며, 시스템은 프로시저를 단위로 분해된다.

  - 시스템은 하나의 커다란 메인 함수다.

    - 프로시저 중심의 기능 분해 관점에서 시스템은 입력 값을 계산해서 출력 값을 반환하는 수학의 함수와 동일하다.
    - 이 관점에서 시스템은 더 작은 작업으로 분해될 수 있는 커다란 메인 함수다.

  - 하향식 접근법(Top-Down Approach)
    - 전통적인 기능 분해 방법은 하향식 접근법을 따른다.
    - 시스템을 구성하는 가장 최상위(topmost) 기능을 정의하고, 이 최상위 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법을 말한다.
    - 분해는 세분화된 마지막 하위 기능이 프로그래밍 언어로 구현 가능한 수준이 될 때까지 계속된다.
    - 상위 기능은 하나 이상의 더 간단하고 더 구체적이며 덜 추상적인 하위 기능의 집합으로 분해된다.
  - 기능 분해 방법에서는 기능을 중심으로 필요한 데이터를 결정한다.
    - 기능이 우선이고 데이터는 기능의 뒤를 따른다.
    - 기능 분해를 위한 하향식 접근법은 먼저 필요한 기능을 생각하고 이 기능을 분해하고 정제하는 과정에서 필요한 데이터의 종류와 저장 방식을 식별한다.
    - 이것은 유지보수에 다양한 문제를 야기한다.



- 하향식 기능 분해의 문제점
  - 시스템은 하나의 메인 함수로 구성되어 있지 않다.
    - 어떤 시스템도 최초에 릴리스 됐던 당시의 모습을 그대로 유지하지 않는다.
    - 시스템이 커질수록 모든 기능을 자식 노드로 가지는 하나의 메인 기능을 선택하기 어려워진다.
    - 하향식 접근법은 하나의 알고리즘을 구현하거나 배치 처리를 구현하기에는 적합하지만 현대적인 상호작용 시스템을 개발하는 데는 적합하지 않다.
  - 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다.
    - 시스템 안에는 여러 개의 정상(top)이 존재하기 때문에 결과적으로 하나의 메인 함수를 유일한 정상으로 간주하는 하향식 기능 분해의 경우에는 새로운 기능을 추가할 때마다 매번 메인 함수를 수정해야 한다.
    - 단일 정상인 메인 함수에서 출발한다는 하향식 접근법의 기본 가정은 새로운 함수가 추가될 때 마다 `main` 함수의 내부 구현을 수정하게 한다.
  - 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다.
    - 하향식 접근법은 비즈니스 로직을 설계하는 초기 단계부터 입력 방법과 출력 양식을 함께 고민하도록 강요한다.
  - 너무 이른 시기에 함수들의 실행 순서를 고정시켜 유연성과 재사용성이 저하된다.
    - 하향식 분해는 시스템이 무엇을 해야하는지가 아니라 어떻게 해야하는지에 집중하게 한다.
    - 하향식 접근법은 시간 제약(temporal constraint)을 강조하여 유연성이 떨어진다.
  - 데이터 변경으로 인한 파급 효과
    - 하향식 기능 분해는 데이터 변경으로 인해 어떤 함수가 영향을 받을지 예상하기 어렵다.





## 모듈과 추상 데이터 타입

- 정보 은닉과 모듈

  - 정보 은닉

    - 시스템을 모듈 단위로 분해하기 위한 기본 원리다.
    - 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 한다는 것이 핵심이다.
    - 외부에 감춰야 하는 비밀에 따라 시스템을 분할하는 모듈 분할 원리다.
    - 모듈은 변경될 가능성이 있는 비밀을 내부로 감추고, 잘 정의되고 쉽게 변경되지 않을 퍼블릭 인터페이스를 외부에 제공해서 내부의 비밀에 함부로 접근하지 못하게 한다.

  - 모듈과 기능분해

    - 시스템을 모듈로 분해한 후에는 각 모듈 내부를 구현하기 위해 기능 분해를 적용할 수 있다.
    - 기능 분해가 하나의 기능을 구현하기 위해 필요한 기능들을 순차적으로 찾아가는 탐색의 과정이라면, 모듈 분해는 감춰야 하는 비밀을 선택하고 비밀 주변에 안정적인 보호막을 설치하는 보존의 과정이다.
    - 비밀을 결정하고 모듈을 분해한 후에는 기능 분해를 이용해 모듈에 필요한 퍼블릭 인터페이스를 구현할 수 있다.

  - 모듈은 다음과 같은 두 가지 비밀을 감춰야 한다.

    - 복잡성: 모듈이 너무 복잡한 경우 이해와 사용이 어렵다. 외부에 추상화할 수 있는 간단한 인터페이스를 제공하여 모듈의 복잡도를 낮춰야한다.

    - 변경 가능성: 변경 가능한 설계 결정이 외부에 노출될 경우 실제로 변경이 발생했을 때 파급효과가 커진다. 변경 발생 시 하나의 모듈만 수정하면 되도록 변경 가능한 설계 결정을 모듈 내부로 감추고 외부에는 쉽게 변경되지 않을 인터페이스를 제공한다.



- 모듈의 장점과 한계
  - 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다.
    - 모듈 내부에 정의된 변수를 직접 참조하는 코드의 위치를 모듈 내부로 제한할 수 있다.
    - 어떤 데이터가 변경됐을 때 영향을 받는 함수를 찾기 위해 해당 데이터를 정의한 모듈만 검색하면 된다.
    - 모듈은 데이터 변경으로 인한 파급 효과를 제어할 수 있기 때문에 코드를 수정하고 디버깅하기가 더 용이하다.
  - 비즈니스 로직과 인터페이스에 대한 관심사를 분리한다.
    - 사용자 인터페이스를 모듈 외부에 구현하여 모듈에서는 비즈니스 로직만 구현하면 된다.
    - 사용자 인터페이스가 변경되더라도 모듈 내부의 비즈니스 로직은 변경되지 않는다.
  - 전역 변수와 전역 함수를 네임스페이스 오염을 방지한다.
    - 모듈의 한 가지 용도는 네임스페이스를 제공하는 것이다.
    - 변수와 함수를 모듈 내부에 포함시키기 때문에 다른 모듈에서도 동일한 이름을 사용할 수 있게 된다.
    - 따라서 전역 네임스페이스의 오염을 방지하는 동시에 이름 충돌의 위험을 완화한다.
  - 모듈 내부는 높은 응집도를 유지하고, 모듈과 모듈 사이는 높은 결합도를 유지한다.
    - 모듈은 기능이 아니라 변경의 정도에 따라 시스템을 분해하게 한다.
    - 각 모듈은 외부에 감춰야 하는 비밀과 관련성 높은 데이터와 함수의 집합이므로 높은 응집도를 유지한다.
    - 모듈과 모듈 사이에는 퍼블릭 인터페이스를 통해서만 통신하므로 낮은 결합도를 유지한다.
  - 모듈의 한계
    - 태생적으로 변경을 관리하기 위한 구현 기법이기에 한계점이 명확하다.
    - 가장 큰 단점은 인스턴스의 개념을 제공하지 않는다는 점이다.
    - 좀 더 높은 수준의 추상화를 위해서는 인스턴스 단위로 다룰 수 있어야한다.



- 추상 데이터 타입

  - 타입

    - 변수에 저장할 수 있는 내용물의 종류와 변수에 적용될 수 있는 연산의 가짓수를 의미한다.
    - 타입은 저장된 값에 대해 수행할 수 있는 연산의 집합을 결정하기 때문에 변수의 값이 어떻게 행동할 것이라는 것을 예측할 수 있게 한다.

  - 데이터 추상화

    - 기능 분해 방식을 사용하던 절차형 언어들은 적은 수의 내장 타입만 제공했으며, 새로운 타입을 추가하는 것이 불가능하거나 제한적이었다.
    - 프로시저 추상화로는 프로그램의 표현력을 향상시키는 데 한계가 있다고 생각한 바바라 리스코프는 데이터 추상화의 개념을 제안했다.
    - 추상 데이터 타입은 추상 객체의 클래스를 정의한 것으로 추상 객체에 사용할 수 있는 오퍼레이션을 이용해 규정된다.
    - 이는 오퍼레이션을 이용해 추상 데이터 타입을 정의할 수 있음을 의미한다.
    - 추상 데이터 객체를 사용할 때 프로그래머는 오직 객체가 외부에 제공하는 행위에만 관심을 가지며 행위가 구현되는 세부 사항에 대해서는 무시한다.

  - 추상 데이터 타입의 의의

    - 사람들은 '직원의 급여를 계산한다'라는 하나의 커다란 절차를 이용해 사고하기 보다는 '직원', '급여'와 같은 추상적인 개념들을 머릿속에 떠올린 후 이들을 이용해 '계산'에 필요한 절차를 생각하는 데 익숙하다.
    - 추상 데이터 타입은 프로시저 추상화 대신 데이터 추상화를 기반으로 소프트웨어를 개발하게 한 최초의 발걸음이다.
    - 추상 데이터 타입은 사람들이 세상을 바라보는 방식에 좀 더 근접해지도록 추상화 수준을 향상시킨다.
    - 모듈과는 달리 추상 데이터 타입은 인스턴스를 생성할 수 있기에 개별 인스턴스를 독립적인 개체로 다루게 해준다.

  - 추상 데이터 타입을 구현하려면 다음과 같은 특성을 위한 프로그래밍 언어의 지원이 필요하다.

    - 타입 정의를 선언할 수 있어야 한다.
    - 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 한다.
    - 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 한다.
    - 타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 한다.


  - 추상 데이터 타입의 한계
    - 추상 데이터 타입 정의를 기반으로 객체를 생성하는 것은 가능하지만 여전히 데이터와 기능을 분리해서 바라본다는 문제가 있다.
    - 추상 데이터 타입은 말 그대로 시스템의 상태를 저장할 데이터를 표현한다.
    - 추상 데이터 타입으로 표현된 데이터를 이용해서 기능을 구현하는 핵심 로직은 추상 데이터 타입 외부에 존재한다.
    - 추상 데이터 타입은 데이터에 대한 관점을 설계의 표면으로 끌어올리기는 하지만 여전히 데이터와 기능을 분리하는 절차적인 설계의 틀에 갇혀 있다.
  - 추상 데이터 타입의 본래 의도는 프로그래밍 언어가 제공하는 타입처럼 동작하는 사용자 정의 타입을 추가할 수 있게 하는 것이다.
    - 프로그래밍 언어 관점에서 추상 데이터 타입은 프로그래밍 언어의 내장 데이터 타입과 동일하다.
    - 추상 데이터 타입에 대한 위와 같은 관점은 클래스와 추상 데이터 타입이 동일한 것인가 하는 의문에 빠지게 한다.





## 클래스

- 클래스는 추상 데이터 타입인가?
  - 클래스가 추상 데이터 타입이라고 보는 관점이 있다.
    - 클래스와 추상 데이터 타입 모두 데이터 추상화를 기반으로 시스템을 분해하기에  이 관점이 꼭 틀린 것은 아니다.
    - 두 메커니즘 모두 외부에서는 객체의 내부 속성에 접근할 수 없으며 오직 퍼블릭 인터페이스를 통해서만 외부와 의사소통 할 수 있다.
  - 명확한 의미에서 둘은 동일하지 않다.
    - 가장 핵심적인 차이는 클래스는 상속과 다형성을 지원하는데, 추상 데이터 타입은 그렇지 않다는 점이다.
    - 상속과 다형성을 지원하는 객체지향 프로그래밍과 구분하기 위해 상속과 다형성을 지원하지 않는 추상 데이터 타입 기반의 프로그래밍을 객체 기반 프로그래밍이라고 부르기도 한다.



- 타입 추상화
  - 추상 데이터 타입의 경우 하나의 대표적인 타입이 다수의 세부적인 타입을 감추기 때문에 윌리엄 쿡은 이를 타입 추상화라 불렀다.
  - 타입 추상화는 개별 오퍼레이션이 모든 개념적인 타입에 대한 구현을 포괄하도록 함으로써 하나의 물리적인 타입 안에 전체 타입을 감춘다.
    - 따라서 타입 추상화는 오퍼레이션을 기준으로 타입을 통합하는 데이터 추상화 기법이다.
    - 타입 추상화를 기반으로 하는 대표적인 기법이 바로 추상 데이터 타입이다.
  - 예를 들어 정규직과 아르바이트를 포함하는 `Employee`라는 추상 데이터 타입이 있다고 가정해보자.
    - `Employee`를 사용하는 클라이언트는 `Employee`의 operation(`calculate_pay` 등)을 호출할 수 있지만, 내부에 정규직이나 아르바이트가 있다는 사실은 알 수 없다.
    - `name`을 인자로 넘겨서 `calculate_pay`를 호출했을 때, 클라이언트는 `calculate_pay`라는 오퍼레이션이 정규직의 임금을 계산할지, 아르바이트의 임금을 계산할지 알 지 못한다.
    - `calculate_pay`라는 오퍼레이션은 정규직과 아르바이트라는 개념적인 타입에 대한 구현을 포괄하기에(즉, 두 타입에 대한 임금 계산을 포괄하기에) 클라이언트 입장에서는 `Employee`라는 물리적인 타입 안에 정규직과 아르바이트라는 전체 타입이 감춰져 있다.
    - 결국 개념적인 타입에 대한 구현을 포괄하는 오퍼레이션을 기준으로 두 개의 타입이 통합된 것이다.
    - 두 직원 타입은 `Employee` 내부에 감춰져 있으며 암묵적이다.



- 객체지향

  - 객체지향과 타입 추상화의 차이
    - 추상 데이터 타입은 오퍼레이션을 기준으로 타입들을 추상화하지만, 클래스는 타입을 기준으로 절차를 추상화한다.
    - 즉, 추상 데이터 타입은 오퍼레이션이 실행될 때 어떤 타입을 대상으로 실행되는지를 추상화하고, 클래스는 어떤 타입의 오퍼레이션을 실행할 때 어떤 오퍼레이션이 실행될지를 추상화한다.
    - 객체지향 에서는 정규직과 아르바이트를 두 개의 타입으로 명시적으로 정의하고 두 직원 유형과 관련된 오퍼레이션의 실행 절차를 두 타입에 분배한다.
    - 결과적으로 객체지향은 정규직과 아르바이트 직원 각각에 대한 클래스를 정의하고 각 클래스들이 필요한 오퍼레이션을 적절하게 구현하게 한다.

  - 객체지향은 절차 추상화다.
    - 정규직과 아르바이트를 두 클래스로 분리할 경우 공통 로직을 어디에 둘 것인지가 문제가 된다.
    - 공통 로직을 포함할 부모 클래스를 정의하고 두 직원 유형의 클래스가 부모 클래스를 상속받게 한다.
    - 클라이언트는 부모 클래스의 참조자에 대해 메시지를 전송하면 실제 클래스가 무엇인가에 따라 적절한 절차가 실행된다.
    - 즉 동일한 메시지에 대해 서로 다르게 반응하는데, 이것이 바로 다형성이다.
    - 실제로 내부에서 수행되는 절차는 다르지만 클래스를 이용한 다형성은 절차에 대한 차이점을 감춘다.
    - 즉, 객체 지향은 절차를 추상화한다.