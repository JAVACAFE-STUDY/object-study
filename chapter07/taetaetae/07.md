# 7. 객체 분해

- 인지 과부화 -> 문제 해결에 필요한 요소의 수가 단기 기억의 용량을 초과하는 순간 문제 해결 능력은 급격하게 떨어짐
- 추상화 -> 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업
- 분해 -> 큰 문제를 해결 가능한 작은 문제로 나누는 작업
- 복잡성을 극복하기 위해 추상화와 분해를 사용

## **01. 프로시저 추상화와 데이터 추상화**

- 프로그램 패러다임 -> 추상화와 분해 관점에서 설명 가능
- 추상화 메커니즘
    - 프로시저 추상화 -> 소프트웨어가 무엇을 해야 하는지
    - 데이터 추상화 -> 소프트웨어가 무엇을 알아야 하는지
- 분해 -> 추상화 결정
    - 프로시저 추상화 중심으로 분해 -> 기능 분해(알고리즘 분해)
    - 데이터 추상화 중심으로 분해
        - 추상 데이터 타입 -> 데이터를 중심으로 타입을 추상화
        - 객체지향 -> 데이터를 중심으로 프로시저를 추상화
- 객체지향언어 관점 -> 데이터 추상화와 프로시저 추상화를 함께 포함한 클래스를 이용해 시스템을 분해

## **02. 프로시저 추상화와 기능 분해**

- **메인 함수로서의 시스템**
    - 기능 분해 관점에서 추상화의 단위는 프로시저, 시스템은 프로시저를 단위로 분해
    - 하향식 접근법 ->시스템을 구성하는 최상위 기능을 정의하고, 더 작은 단계의 하위 기능으로 분해하는 방법
- **급여 관리 시스템**
    - 최상위 기능을 수행하는 데 필요한 절차들을 실행되는 시간 순서에 따라 나열
    - 최상위 문장
        - 직원의 급여를 계산
    - 세부절차(기능분해)
        - 직원의 급여를 계산
            - 사용자로부터 소득세율을 입력 받음
            - 직원의 급여를 계산
            - 양식에 맞게 결과를 출력
    - 구체화
        - 직원의 급여를 계산
            - 사용자로부터 소득세율을 입력 받음
                - "세율을 입력 : " 화면에 출력
                - 키보드를 통해 세율을 입력 받음
            - 직원의 급여를 계산
                - 전역 변수에 저장된 직원의 기본급 정보를 얻음
                - 급여를 계산
            - 양식에 맞게 결과를 출력
                - "이름 : {직원명}, 급여 : {계산된 금액} " 형식에 따라 출력 문자열을 생성
    - 기능 분해 방법 -> 기능을 중심으로 필요한 데이터를 결정 -> 유지보수의 문제점 발생
- **급여 관리 시스템 구현**
    - 하향식 기능 분해는 트리 구조가 됨
- **하향식 기능 분해의 문제점**
    - 문제
        - 시스템은 하나의 메인 함수로 구성돼 있지 않음
        - 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 함
        - 비즈니스 로직이 사용자 인터페이스와 강하게 결합
            - 사용자 인터페이스의 관심사와 비즈니스 로직의 관심사를 동시에 고려해야 함 -> "관심사의 분리"라는 아키텍처 설계의 목적에 달성하기 어려움
        - 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하
            - 무엇이 아닌 어떻게에 집중 됨 -> 결합도가 높음
        - 데이터 형식이 변경될 경우 파급효과를 예측 할 수 없음
            - 어떤 데이터를 어떤 함수가 사용하고 있는지 추측하기 어려움
- **언제 하향식 분해가 유용한가?**
    - 시스템이 안정화 되었을때 논리적인 설명과 문서화하기에 용이

## **03. 모듈**

- 정보은닉 -> 시스템을 모듈 단위로 분해하기 위한 기본 월리로 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 한다는 것
- 모듈 -> 변경될 가능성이 있는 비밀을 내부로 감추고, 잘 정의되고 쉽게 변경되지 않을 퍼블릭 인터페이스를 외부에 제공해서 내부의 비밀에 함부로 접근 못하게 함
    - 복잡성 -> 외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해서 복잡도를 낮춤
    - 변경 가능성 -> 변경 가능한 설계 결정을 모듈 내부로 감추고 쉽게 변경되지 않을 인터페이스를 외부에 제공
- **모듈의 장점과 한계**
    - 장점
        - 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미침
        - 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리
        - 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지

## **04. 데이터 추상화와 추상 데이터 타입**

- **추상 데이터 타입**
    - 타입 -> 변수에 저장할 수 있는 내용물의 종류와 변수에 적용될 수 있는 연산의 가짓수
    - 추상 데이터 타입 구현
        - 타입 정의를 선언할 수 있어야 함
        - 타임의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 함
        - 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 함
        - 타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 함

## **05. 클래스**

- **클래스는 추상 데이터 타입인가?**
    - 클래스 ->상속과 다형성을 지원함 -> 객체지향 프로그래밍 -> 절차를 추상화 -> 타입 기준
    - 추상 데이터 타입 -> 지원X -> 객체기반 프로그래밍 -> 타입을 추상화 -> 오퍼레이션을 기준
- **추상 데이터 타입에서 클래스로 변경하기**
    - 각 직원 타입을 독립적인 클래스로 구현
    - 두 개의 타입이 존재한다는 사실을 명시적으로 표현
- **변경을 기준으로 선택하라**
    - 개방-폐쇄 원칙(OCP) -> 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성
    - 설계의 유용성은 변경의 반향성과 발생 빈도에 따라 결정
    - 새로운 타입을 빈번하게 추가해야 하면 객체지향의 클래스 구조가 유용
    - 새로운 오퍼레이션을 빈번하게 추가해야 하면 추상 데이터 타입이 유용
- **협력이 중요하다**
    - 객체지향에서 중요한 건 역할, 책임, 협력
    - 객체가 참여할 협력을 결정하고 협력에 필요한 책임을 수행하기 위해 어떤 객체가 필요한지에 고민해야 함
    - 그 책임을 다양한 방식으로 수행해야 할 때만 타입 계층 안에 각 절차를 추상화 하기
    - 타입 계층과 다형성은 협력이라는 문맥 안에서 책임을 수행하는 방법에 관해 고민한 결과물이어야 하며 그 자체가 목적이 되서는 안됨
