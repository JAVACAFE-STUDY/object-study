# 설계 품질과 트레이드오프

- 객체지향 설계
  - 객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다.
    - 객체지향 설계에 관한 이 정의에는 두 가지 관점이 섞여 있다.
    - 첫 번째 관점은 객체지향 설계의 핵심이 책임이라는 것이다.
    - 두 번째 관점은 책임을 할당하는 작업이 응집도와 결합도 같은 설계 품질과 깊이 연관돼 있다는 것이다.
  - 훌륭한 설계란 합리적인 비용 안에서 변경을 수용할 수 있는 구조를 만드는 것이다.
    - 설계는 변경을 위해 존재하고 변경에는 어떤 식으로든 비용이 발생한다.
    - 적절한 비용 안에서 쉽게 변경할 수 있는 설계는 응집도가 높고 서로 느슨하게 결합돼 있는 요소로 구성된다.
  - 훌륭한 객체지향 설계는 데이터가 아니라 책임에 초점을 맞춰야한다.
    - 객체의 상태는 구현에 속하며, 구현은 불안정하기 때문에 변하기 쉽다.
    - 상태를 객체 분할의 중심축으로 삼으면 구현에 관한 세부사항이 객체의 인터페이스에 스며들게 되어 캡슐화의 원칙이 무너진다.
    - 반면에 객체의 책임은 인터페이스에 속한다.
    - 객체는 책임을 드러내는 안정적인 인터페이스 뒤로 책임을 수행하는 데 필요한 상태를 캡슐화하여 구현 변경에 대한 파장이 외부로 퍼지는 것을 방지한다.
    - 따라서 책임에 초점을 맞추면 상대적으로 변경에 안정적인 설계를 얻을 수 있게 된다.



- 좋은 설계를 판단하는 기준
  - 캡슐화
    - 객체를 설계하기 위한 가장 기본적인 아이디어는 변경의 정도에 따라 구현과 인터페이스를 분리하고 외부에서는 인터페이스에만 의존하도록 의존관계를 조절하는 것이다.
    - 설계가 필요한 이유는 요구사항이 변경되기 때문이고, 캡슐화가 중요한 이유는 불안정한 부분과 안정적인 부분을 분리해서 변경의 영향을 통제할 수 있기 때문이다.
    - 따라서 변경의 관점에서 설계의 품질을 판단하기 위해 캡슐화를 기준으로 삼을 수 있다.
  - 응집도
    - 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다.
    - 객체지향 관점에서 응집도는 객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는지를 나타낸다.
    - 변경의 관점에서 응집도란 **변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도**로 측정할 수 있다.
    - 응집도가 높을수록 변경의 대상과 범위가 명확해지기 때문에 코드를 변경하기 쉬워진다.
  - 결합도
    - 결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도다.
    - 객체지향 관점에서 결합도는 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는지를 나타낸다.
    - 변경의 관점에서 결합도란 **한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도**로 측정할 수 있다.
    - 결합도가 높으면 변경해야 하는 모듈의 수가 늘어나기 때문에 변경하기가 어려워진다.



- 데이터 중심 영화 예매 시스템의 문제점

  - 캡슐화를 위반한다.

    - 접근자와 수정자는 객체 내부의 상태에 대한 어떤 정보도 캡슐화하지 못한다.
    - 접근자와 수정자는 객체 내부에 어떤 인스턴스 변수가 있는지를 퍼블릭 인터페이스에 노골적으로 드러낸다.
    - 변경된 코드가 캡슐화의 원칙을 어기게 된 근본적인 원인은 객체가 수행할 책임이 아니라 내부에 저장할 데이터에 초점을 맞췄기 때문이다.
    - 구현을 캡슐화할 수 있는 적절한 책임은 협력이라는 문맥을 고려할 때만 얻을 수 있다.
    - 설계를 할 때 협력에 대해 고민하지 않으면 캡슐화를 위반하는 과도한 접근자와 수정자를 가지게 되는 경향이 있다.
    - 객체가 사용될 문맥을 추측할 수 밖에 없는 경우 개발자는 어떤 상황에서든 해당 객체가 사용될 수 있게 최대한 많은 접근자 메서드를 추가하게 된다.

    - 앨런 홀럽은 접근자와 수정자에 과도하게 의존하는 설계 방식을 추측에 의한 설계(design-by-guessing strategy)라고 부른다.
    - 이 전략은 객체가 사용될 협력을 고려하지 않고 객체가 다양한 상황에서 사용될 수 있을 것이라는 막연한 추측을 기반으로 설계를 진행한다.
    - 따라서 프로그래머는 내부 상태를 드러내는 메서드를 최대한 많이 추가해야 한다는 압박에 시달릴 수 밖에 없으며 결과적으로 대부분이 내부 구현이 퍼블릭 인터페이스에 그대로 노출될 수밖에 없다.
    - 결과적으로 캡슐화 원칙을 위반하는 변경에 취약한 설계를 얻게 된다.
  - 결합도가 높다.

    - 위 코드는 객체 내부의 구현이 객체의 인터페이스에 드러난다.
    - 이는 클라이언트가 구현에 강하게 결합된다는 것을 의미하며, 더 큰 문제는 객체의 내부 구현을 변경할 경우 이 인터페이스에 의존하는 모든 클라이언트들도 함께 변경해야 한다는 것이다.
    - 데이터 중심 설계는 객체의 캡슐화를 약화시키기 때문에 클라이언트가 객체의 구현과 강하게 결합된다.
    - 결합도 측면에서 데이터 중심 설계가 가지는 또 다른 단점은 여러 데이터 객체들을 사용하는 제어 로직이 특정 객체 안에 집중되기 때문에 하나의 제어 객체가 다수의 데이터 객체에 강하게 결합된다는 것이다.
    - 제어 객체인 `ReservationAgency`는 대부분의 제어 로직을 가지고 있으며, 모든 데이터 객체에 의존하고 있다.
    - 따라서 데이터 객체의 변경 사항은 `ReservationAgency`에게도 영향을 미칠 확률이 높다.
    - 위 코드에서 `ReservationAgency`는 모든 의존성이 모이는 결합도의 집결지다.
    - 데이터 중심 설계는 이처럼 전체 시스템을 하나의 거대한 의존성 덩어리로 만들어 버린다.
  - 응집도가 낮다.

    - `ReservationAgency`는 할인 정책이 추가 되거나, 할인 정책별 할인 요금 계산 방식이 변경되거나, 할인 조건이 추가되거나, 예상 요금을 계산하는 방식이 변경되거나, 할인 조건별로 할인 여부를 판단하는 방법이 변경될 경우 수정되어야 한다.
    - 이처럼 서로 다른 이유로 변경되는 코드들이 하나의 모듈 안에 뭉쳐있으므로 위 코드는 응집도가 낮다고 할 수 있다.
    - 응집도가 낮을 경우 변경과 아무 상관이 없는 코드들도 변경에 의한 영향을 받게 된다.
    - 어떤 코드를 수정한 후에 아무 상관도 없던 코드에서 문제가 발생하는 것은 모듈의 응집도가 낮을 때 발생하는 대표적인 증상이다.
    - 또한 응집도가 낮을 경우 요구사항이 변경 되면 동시에 여러 모듈을 수정해야한다.
    - 이는 응집도가 낮을 경우 다른 모듈에 위치해야 할 책임의 일부가 엉뚱한 곳에 위치하게 되기 때문이다.
    - 어떤 요구사항 변경을 수용하기 위해 하나 이상의 클래스를 수정해야 하는 것은 설계의 응집도가 낮다는 증거다.



- 자율적은 객체를 만드는 방법

  - 캡슐화를 지켜라
    - 데이터 중심의 설계가 낮은 응집도와 높은 결합도라는 문제를 갖게 된 이유는 바로 캡슐화를 위반했기 때문이다.
    - 객체는 자신이 어떤 데이터를 가지고 있는지를 내부에 캡슐화하고 외부에 공개해서는 안 된다.
    - 객체는 스스로의 상태를 책임져야 하며 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야한다.
    - 여기서 말하는 메서드는 접근자나 수정자를 의미하는 것이 아닌, 객체가 책임져야 하는 무언가를 수행하는 메서드다.
    - 속성의 가시성을 private으로 설정했다고 해도 접근자와 수정자를 통해 속성을 외부로 제공하고 있다면 캡슐화를 위반하는 것이다.
  - 스스로 자신의 데이터를 책임지는 객체를 만들어라
    - 객체는 단순한 데이터 제공자가 아니며, 객체 내부에 저장되는 데이터보다 객체가 협력에 참여하면서 수행할 책임을 정의하는 오퍼레이션이 더 중요하다.
    - 객체는 자신들의 책임을 수행하기 위해 필요한 데이터를 저장해야 하며, 마찬가지로 자신들이 가지고 있는 데이터를 처리하는 데 필요한 메서드는 객체 스스로 구현해야 한다.
    - 사실 이 방식은 책임 중심 개발 방식이라기 보다는 데이터 중심 개발 방식을 책임 중심 개발 방식에 가깝게 옮기는 것에 불과하다.
    - 실제 책임 중심 개발 방식을 사용했다면, 책임을 먼저 결정하고, 그에 필요한 데이터를 정의하므로 이런 상황이 나올 수 없다.



- 데이터 중심 설계의 문제점
  - 데이터 중심 설계는 아래와 같은 이유로 변경에 취약하다.
  - 데이터 중심 설계는 행동 보다 상태에 초점을 맞춘다.
    - 데이터 중심 설계는 설계의 시작 단계부터 데이터에 관해 결정하도록 강요하기 때문에 너무 이른 시기에 내부 구현에 초점을 맞추게 한다.
    - 데이터 중심 설계 방식에 익숙한 개발자들은 일반적으로 데이터와 기능을 분리하는 절차적 프로그래밍 방식을 따른다.
    - 데이터 중심 설계에서 객체는 그저 데이터의 집합체일 뿐이고, 이로 인해 접근자와 수정자를 과하게 추가하게 된다.
    - 그리고 이 데이터 객체를 사용하는 절차를 별도의 객체 안에 구현하게 되는데, 이럴 경우 캡슐화가 무너지게 된다.
    - 비록 데이터를 처리하는 작업과 데이터를 같은 객체에 두더라도 데이터에 초점이 맞춰져 있다면 캡슐화가 무너질 확률이 높다.
    - 데이터를 먼저 결정하고 데이터를 처리하는 데 필요한 오퍼레이션을 나중에 결정하는 방식은 데이터에 관한 지식이 객체의 인터페이스에 고스란히 드러나기 때문이다.
  - 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다.
    - 데이터 중심 설계에서 초점은 객체 사이의 협력이라는 외부가 아니라, 객체 내부로 향한다.
    - 실행 문맥에 대한 고민 없이 객체가 관리할 데이터의 세부 정보를 먼저 결정한다.
    - 객체의 구현이 이미 결정된 상태에서 다른 개체와의 협력 방법을 고민하기 위해 이미 구현된 객체의 인터페이스를 억지로 끼워맞출 수밖에 없다.
    - 그리고 이는 하나의 변경 사항으로 인해 많은 객체가 변경되는 코드를 만든다.
