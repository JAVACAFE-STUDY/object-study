# 객체지향 프로그래밍

- 협력, 객체, 클래스
  - 객체지향은 클래스가 아닌 객체에 초점을 맞춰야한다.
    - 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민해야한다.
    - 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것이다.
    - 따라서 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야한다.
    - 객체를 중심에 두는 접근 방법은 설계를 단순하고 깔끔하게 만든다.
  - 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다.
    - 객체는 다른 객체에게 도움을 주거나 의존하면서 살아가는 협력적인 존재다.
    - 객체를 협력하는 공동체의 일원으로 바라보는 것은 설계를 유연하고 확장 가능하게 만든다.
  - 객체의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고 이 타입을 기반으로 클래스를 구현해야한다.
    - 훌륭한 협력이 훌륭한 객체를 낳고, 훌령한 객체가 훌륭한 클래스를 낳는다.



- 클래스 구현하기
  - 클래스를 구현할 때 가장 중요한 것은 클래스의 경계를 구분 짓는 것이다.
    - 클래스는 내부와 외부로 구분되며 훌륭한 클래스를 설계하기 위한 핵심은 어떤 부분을 외부에 공개하고 어떤 부분을 감출지를 결정하는 것이다.
    - 클래스와 내부와 외부를 구분해야 하는 이유는 **경계의 명확성이 객체의 자율성을 보장**하기 때문이다.
    - 또한 이를 통해 프로그래머에게 구현의 자유를 제공하기 때문이다.
  - 자율적인 객체
    - 객체는 상태와 행동을 함께 가지는 복합적인 존재이면서, 스스로 판단하고 행동하는 자율적인 존재이다.
    - 객체지향 이전의 패러다임과 달리 객체지향에서는 객체라는 단위 안에 데이터와 기능을 한 덩어리로 묶는다.
    - 이처럼 데이터와 기능을 객체 내부로 함께 묶는 것을 캡슐화라고 부른다.
    - 대부분의 객체지향 프로그래밍 언어들은 캡슐화에서 한 걸음 더 나아가서 접근 제어(access control) 매커니즘을 함께 제공한다.
    - **객체 내부에 대한 접근을 통제하는 이유는 객체를 자율적인 존재로 만들기 위해**서다.
    - 객체지향의 핵심은 자율적인 객체들의 공동체를 구성하는 것이며, 객체가 자율적이기 위해서는 외부의 간섭을 최소화해야 한다.
    - 외부에서는 객체가 어떤 상태에 놓여 있는지, 어떤 생각을 하고 있는지 알아서는 안 되며, 결정에 직접 개입하려고 해서도 안 된다.
    - 캡슐화와 접근 제어는 객체를 외부에서 접근 가능한 퍼블릭 인터페이스와 내부에서만 접근 가능한 구현으로 나눈다.
    - 이 인터페이스와 구현의 분리 원칙은 객체지향 프로그램을 만들기 위해 따라야 하는 핵심 원칙이다.



- 협력(Collaboration)
  - 시스템의 어떤 기능을 구현하기 위해 객체들 사이에 이뤄지는 상호작용을 협력이라고 부른다.
    - 객체지향 프로그램을 작성할 때는 먼저 협력의 관점에서 어떤 객체가 필요한지를 결정하고, 객체들의 공통 상태와 행위를 구현하기 위해 클래스를 작성한다.
  - 협력의 방식
    - 객체는 다른 객체의 엔터페이스에 공개된 행동을 수행하도록 요청 할 수 있다.
    - 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답한다.
    - 객체가 다른 객체와 상호작용 할 수 있는 유일한 방법은 메시지를 전송하는 것이다.
    - 다른 객체에게 요청이 도착할 때 해당 객체가 메시지를 수신했다고 이야기한다.
    - 메시지를 수신한 객체는 스스로의 결정에 따라 자율적으로 메시지를 처리할 방법을 결정한다.
  - 메서드와 메시지
    - 수신된 메시지를 처리하기 위한 자신만의 방법을 메서드라 부른다.
    - 메시지와 메서드를 구분하는 것은 매우 중요하며, 이를 구분하는 것에서 다형성의 개념이 출발한다.



- 상속
  - 차이에 의한 프로그래밍(Programming by difference)
    - 클래스를 추가하려 할 때, 해당 클래스가 기존의 어떤 클래스와 매우 흡사하다면, 상속을 이용해 기존 클래스가 가지고 있는 모든 속성과 행동을 새로운 클래스에 포함시킬 수 있다.
    - 상속은 기존 클래스를 기반으로 새로운 클래스를 쉽고 빠르게 추가할 수 있는 간편한 방법을 제공한다.
    - 또한 상속을 이용하면 부모 클래스의 구현은 공유하면서도 행동이 다른 자식 클래스를 쉽게 추가할 수 있다.
    - 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 차이에 의한 프로그래밍이라 부른다.
  - 상속과 인터페이스
    - 상속이 가치있는 이유는 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문이다.
    - 이는 상속의 목적이 메서드나 인스턴스 변수의 재사용이라는 일반적인 인식과는 거리가 있다.
    - 인터페이스는 객체가 이해할 수 있는 메시지의 목록이며, 상속을 통해 자식 클래스는 자신의 인터페이스에 부모 클래스의 인터페이스를 포함하게 된다.
    - 결과적으로 자식 클래스는 부모 클래스가 수신할 수 있는 모든 메시지를 수신할 수 있기 때문에 외부 객체는 자식 클래스를 부모 클래스와 동일한 타입으로 간주할 수 있다.
  - 구현 상속과 인터페이스 상속
    - 구현 상속을 흔히 서브클래싱(subclassing)이라 부르고, 인터페이스 상속을 서브타이핑(subtyping)이라 부른다.
    - 순수하게 코드를 재사용하기 위한 목적으로 상속을 사용하는 것을 구현 상속이라 부른다.
    - 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용하는 것을 인터페이스 상속이라 부른다.
    - 상속은 구현 상속이 아니라 인터페이스 상속을 위해 사용해야 한다.
    - 대부분의 사람들은 코드 재사용을 상속의 주된 목적이라고 생각하지만, 이는 오해다.
    - 인터페이스를 재사용할 목적이 아니라 구현을 재사용할 목적으로 상속을 사용하면 변경에 취약한 코드를 낳게 될 확률이 높다.



- 다형성

  - 다형성의 개념
    - 메시지와 메서드는 다른 개념이다.
    - 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라지는 것을 다형성이라 부른다.
    - 다형성은 객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반으로 한다.

  - 상속과 다형성
    - 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야한다.
    - 즉 인터페이스가 동일해야한다.
    - 그리고 두 클래스의 인터페이스를 통일하기 위해 사용하는 구현 방법이 바로 상속인 것이다.
    - 그러나 상속이 다형성을 구현할 수 있는 유일한 방법인 것은 아니다.
  - 동작 바인딩과 정적 바인딩
    - 다형성을 구현하는 방법은 다양하지만, 메시지에 응답하기 위해 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정한다는 공통점이 있다.
    - 즉 메시지와 메서드를 실행 시점에 바인딩 하는데, 이를 지연 바인딩(lazy binding) 혹은 동적 바인딩(dynamic binding)이라 부른다.
    - 이에 반해 전통적인 함수 호출처럼 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것을 초기 바인딩(early binding) 혹은 정적 바인딩(static binding)이라 부른다.
    - 객체지향이 컴파일 시점의 의존성과 실핼 시점의 의존성을 분리하고, 하나의 메시지를 선택적으로 서로 다른 메서드에 연결할 수 있는 이유가 바로 지연 바인딩이라는 메커니즘 덕분이다.



- 상속의 악영향
  - 상속은 코드를 재사용하기 위해 널리 사용되는 방법이지만, 널리 사용되는 방법이라고 해서 가장 좋은 방법인 것은 아니다.
  - 상속은 캡슐화를 위반한다.
    - 상속을 이용하기 위해서는 부모 클래스의 내부 구조를 잘 알고 있어야 한다.
    - 부모 클래스의 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화된다.
    - 캡슐화의 약화는 자식 클래스가 부모 클래스에 강하게 결합되도록 만들기 때문에 부모 클래스를 변경할 때 자식 클래스도 함께 변경될 확률을 높인다.
  - 상속은 유연하지 않은 설계를 만든다.
    - 상속은 부모 클래스와 자식 클래스의 관계를 컴파일 시점에 결정한다.
    - 따라서 실행 시점에 객체의 종류를 변경하는 것이 불가능하다.



- 합성

  - 합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법을 말한다.

    - 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법을 합성이라고 부른다.
    - 상속과 다른 점은 상속이 부모 클래스의 코드와 자식 클래스의 코드를 컴파일 시점에 하나의 단위로 강하게 결합하는 데 비해 합성은 인터페이스를 통해 약하게 결합된다는 것이다.
  - 코드 재사용을 위해서는 상속보다 합성(composition)이 더 좋은 방법이다.

    - 합성은 상속이 가지는 두 가지 문제점을 모두 해결한다.
    - 인터페이스에 정의된  메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있다.
    - 또한 의존하는 인터페이스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만든다.
    - 상속은 클래스를 통해 강하게 결합되는 데 비해 합성은 메시지를 통해 느슨하게 결합된다.

    - 따라서 코드 재사용을 위해서는 상속보다 합성을 선호하는 것이 더 좋은 방법이다.

